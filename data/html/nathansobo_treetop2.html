<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>nathansobo_treetop2</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="ordered-choices">Ordered Choices</h2>
<p>Ordered choices are <em>composite expressions</em>, which allow for any of several subexpressions to be matched. These should be familiar from regular expressions, but in parsing expressions, they are delimited by the <code>/</code> character. Its important to note that the choices are prioritized in the order they appear. If an earlier expression is matched, no subsequent expressions are tried. Here’s an example:</p>
<pre><code># my_grammar.treetop
grammar MyGrammar
  rule hello
    &#39;hello chomsky&#39; / &#39;hello lambek&#39;
  end
end</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># fragment of use_grammar.rb</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">puts parser.parse(<span class="st">&#39;hello chomsky&#39;</span>)         <span class="co"># =&gt; Treetop::Runtime::SyntaxNode</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">puts parser.parse(<span class="st">&#39;hello lambek&#39;</span>)          <span class="co"># =&gt; Treetop::Runtime::SyntaxNode</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">puts parser.parse(<span class="st">&#39;silly generativists!&#39;</span>)  <span class="co"># =&gt; nil</span></a></code></pre></div>
<p>Note that once a choice rule has matched the text using a particular alternative at a particular location in the input and hence has succeeded, that choice will never be reconsidered, even if the chosen alternative causes another rule to fail where a later alternative wouldn’t have. It’s always a later alternative, since the first to succeed is final - why keep looking when you’ve found what you wanted? This is a feature of PEG parsers that you need to understand if you’re going to succeed in using Treetop. In order to memoize success and failures, such decisions cannot be reversed. Luckily Treetop provides a variety of clever ways you can tell it to avoid making the wrong decisions. But more on that later.</p>
<h2 id="sequences">Sequences</h2>
<p>Sequences are composed of other parsing expressions separated by spaces. Using sequences, we can tighten up the above grammar.</p>
<pre><code># my_grammar.treetop
grammar MyGrammar
  rule hello
    &#39;hello &#39; (&#39;chomsky&#39; / &#39;lambek&#39;)
  end
end</code></pre>
<p>Note the use of parentheses to override the default precedence rules, which bind sequences more tightly than choices.</p>
<p>Once the whole sequence has been matched, the result is memoized and the details of the match will not be reconsidered for that location in the input.</p>
<h2 id="nonterminal-symbols">Nonterminal Symbols</h2>
<p>Here we leave regular expressions behind. Nonterminals allow expressions to refer to other expressions by name. A trivial use of this facility would allow us to make the above grammar more readable should the list of names grow longer.</p>
<pre><code># my_grammar.treetop
grammar MyGrammar
  rule hello
    &#39;hello &#39; linguist
  end
  
  rule linguist
    &#39;chomsky&#39; / &#39;lambek&#39; / &#39;jacobsen&#39; / &#39;frege&#39;
  end
end</code></pre>
<p>The true power of this facility, however, is unleashed when writing <em>recursive expressions</em>. Here is a self-referential expression that can match any number of open parentheses followed by any number of closed parentheses. This is theoretically impossible with regular expressions due to the <em>pumping lemma</em>.</p>
</body>
</html>
