<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>jimweirich_flexmock4</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>call to flexmock.</p>
<ul>
<li><p><b>mock = flexmock(“joe”, :on, <em>User</em>)</b></p>
<p>This defines a strict mock that is based on the User class. Strict mocks prevent you from mocking or stubbing methods that are not instance methods of the restricting class (i.e. User in our example). This helps prevent tests from becoming stale with incorrectly mocked objects when the method names change.</p>
<p>Use the <code>explicitly</code> modifier to <code>should_receive</code> to override the strict mock restrictions.</p></li>
<li><p><b>partial_mock = flexmock(<em>real_object</em>)</b></p>
<p>If you you give <code>flexmock</code> a real object in the argument list, it will treat that real object as a base for a partial mock object. The return value <code>partial_mock</code> may be used to set expectations. The real_object should be used in the reference portion of the test.</p></li>
<li><p><b>partial_mock = flexmock(<em>real_object</em>, :on, <em>class_object</em>)</b></p></li>
<li><p><b>partial_mock = flexmock(<em>real_object</em>, :strict)</b></p>
<p>Partial mocks can also take a restricting base, so that you cannot mock methods not in the class (without the <code>explicitly</code> modifier). Since partials already have a class, you can use the <code>:strict</code> keyword to mean the same thing as <code>:on, <em>real_object</em>.class</code>.</p></li>
<li><p><b>partial_mock = flexmock(<em>real_object</em>, “name”, :foo =&gt; :baz)</b></p>
<p>Names and expectation hashes may be used with partial mocks as well.</p></li>
<li><p><b>partial_mock = flexmock(:base, <em>real_string_object</em>)</b></p>
<p>Since Strings (and Symbols for that matter) are used for mock names, FlexMock will not recognize them as the base for a partial mock. To force a string to be used as a partial mock base, proceed the string object in the calling sequence with :base.</p></li>
<li><p><b>partial_mock = flexmock(:safe, <em>real_object</em>) { |mock| mock.should_receive(…) }</b></p>
<p>When mocking real objects (i.e. “partial mocks”), FlexMock will add a handful of mock related methods to the actual object (see below for list of method names). If one or more of these added methods collide with an existing method on the partial mock, then there are problems.</p>
<p>FlexMock offers a “safe” mode for partial mocks that does not add</p></li>
</ul>
</body>
</html>
