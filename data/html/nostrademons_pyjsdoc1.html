<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>nostrademons_pyjsdoc1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Python port of JSDoc.</p>
<h2 id="installation">Installation</h2>
<p>The complete script and API is in one Python sourcefile - pyjsdoc.py. Drop this onto your PYTHONPATH to use as a library, or put/symlink it on your PATH to use as a standalone command-line utility.</p>
<p>Alternatively, this may be installed via “easy_install pyjsdoc”.</p>
<h2 id="usage">Usage</h2>
<p>The syntax of doc comments and set of supported tags is mostly compatible with the style than JSDoc. It has the following differences:</p>
<ul>
<li><span class="citation" data-cites="class">@class</span> should be used in a separate doc comment instead of being a tag in the constructor’s comment. Note that the original JSDoc style still works, it’ll just pick up the whole constructor’s doc comment as class documentation instead of just the <span class="citation" data-cites="class">@class</span> tag.</li>
<li><span class="citation" data-cites="ignore">@ignore</span> is supported, but useless. PyJSDoc determines which functions/methods to document by the presence of doc comments: undocumented functions never show up in the final documentation.</li>
<li>Instead of the <span class="citation" data-cites="requires">@requires</span> class dependency tag, PyJSDoc provides an <span class="citation" data-cites="dependency">@dependency</span> tag in the fileoverview block, which takes a filename (relative to source path). This performs transitive dependency analysis on all files in the sourcebase, giving you a list of all files that you need to include to use the specified module.</li>
<li>Instead of separate <span class="citation" data-cites="type">@type</span> and <span class="citation" data-cites="return">@return</span> tags, you can format an <span class="citation" data-cites="return">@return</span> or <span class="citation" data-cites="returns">@returns</span> tag like you would a parameter, as “{Type} Description text”, and the parser will pick it up. You can also use the original JSDoc approach.</li>
<li>The <span class="citation" data-cites="fileoverview">@fileoverview</span> block supports the additional tags <span class="citation" data-cites="license">@license</span> and <span class="citation" data-cites="organization">@organization</span>, which take text strings describing the module.</li>
</ul>
<p>Command-line options are described in the usage text:</p>
<pre><code>./pyjsdoc.py --help</code></pre>
<p>Also check out the examples, and build the documentation for them:</p>
<pre><code>./pyjsdoc.py -p examples</code></pre>
<h2 id="extensibility">Extensibility</h2>
<p>When used as a library, PyJSDoc is fully extensible without configuration. Unrecognized tags are accessible as dictionary fields from the appropriate ModuleDoc/FunctionDoc/ClassDoc object. For example, the following doc comment:</p>
<pre><code>/**
 * A function with additional info.
 * @function fn_name
 * @my_custom_tag This is custom tag text
 */</code></pre>
<p>Is accessible through the Python API as:</p>
<pre><code>&gt;&gt;&gt; file[&#39;fn_name&#39;][&#39;my_custom_tag&#39;]
This is custom tag text.</code></pre>
<p>In PyJSDoc’s parent project, we used this in a few places:</p>
<ul>
<li>Dependency analysis for automated tests. We added an <span class="citation" data-cites="has_test">@has_test</span> tag to every module with a JSUnit test file, then rebuilt the <code>&lt;script src=&gt;</code> tags in the JSUnit file from the all_dependencies module field, so that whenever an upstream dependency changed, we didn’t need to manually change every dependent test file.</li>
<li>GUI generation for front-end JS classes. In several cases, we had a domain model class that needed to be represented in the UI. Rather than manually code that logic into the app, we added “<span class="citation" data-cites="widget">@widget</span> {WidgetClass} label Help text” tags to the JSDocs, and then used that to dynamically instantiate UI widgets on the front end.</li>
</ul>
<p>Also, the -j (–json) command-line switch lets you dump the JSDoc parse tree in JSON format, which lets you use the PyJSDoc front-end from other languages.</p>
<h2 id="history">History</h2>
</body>
</html>
