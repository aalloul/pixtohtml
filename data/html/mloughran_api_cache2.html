<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>mloughran_api_cache2</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>To understand what <code>APICache</code> does here’s an example: Given cached data less than 10 minutes old, it returns that. Otherwise, assuming it didn’t try to request the URL within the last minute (to avoid the rate limit), it makes a get request to the supplied url. If the Twitter API timeouts or doesn’t return a 2xx code (very likely) we’re still fine: it just returns the last data fetched (as long as it’s less than a day old). In the exceptional case that all is lost and no data can be returned, a subclass of <code>APICache::APICacheError</code> is raised which you’re responsible for rescuing.</p>
<p>Assuming that you don’t care whether it was a timeout error or an invalid response (for example) you could do this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">begin</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">APICache</span>.get(<span class="st">&quot;http://twitter.com/statuses/public_timeline.rss&quot;</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">rescue</span> <span class="dt">APICache</span>::<span class="dt">APICacheError</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="st">&quot;Fail Whale&quot;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">end</span></a></code></pre></div>
<p>However there’s an easier way if you don’t care exactly why the API call failed. You can just pass the :fail parameter (procs are accepted too) and all exceptions will be rescued for you. So this is exactly equivalent:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">APICache</span>.get(<span class="st">&quot;http://twitter.com/statuses/public_timeline.rss&quot;</span>, {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="st">:fail</span> =&gt; <span class="st">&quot;Fail Whale&quot;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">})</a></code></pre></div>
<p>The real value however is not caching HTTP calls, but allowing caching functionality to be easily added to existing API client gems, or in fact any arbitrary code which is either slow or not guaranteed to succeed every time.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">APICache</span>.get(<span class="st">&#39;twitter_replies&#39;</span>, <span class="st">:cache</span> =&gt; <span class="dv">3600</span>) <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="dt">Net</span>::<span class="dt">HTTP</span>.start(<span class="st">&#39;twitter.com&#39;</span>) <span class="kw">do</span> |http|</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    req = <span class="dt">Net</span>::<span class="dt">HTTP</span>::<span class="dt">Get</span>.new(<span class="st">&#39;/statuses/replies.xml&#39;</span>)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    req.basic_auth <span class="st">&#39;username&#39;</span>, <span class="st">&#39;password&#39;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    response = http.request(req)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="kw">case</span> response</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">when</span> <span class="dt">Net</span>::<span class="dt">HTTPSuccess</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      <span class="co"># 2xx response code</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">      response.body</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="kw">else</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">      raise <span class="dt">APICache</span>::<span class="dt">InvalidResponse</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  <span class="kw">end</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">end</span></a></code></pre></div>
<p>The first argument to <code>APICache.get</code> is now assumed to be a unique key rather than a URL. As you’d expect, the block will only be called if the request cannot be fulfilled by the cache. Throwing any exception signals to <code>APICache</code> that the request was not successful, should not be cached, and a cached value should be returned if available. If a cached value is not available then the exception will be re-raised for you to handle.</p>
<p>You can send any of the following options to <code>APICache.get(url, options = {}, &amp;block)</code>. These are the default values (times are all in seconds):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb4-1" data-line-number="1">{</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="st">:cache</span> =&gt; <span class="dv">600</span>,    <span class="co"># 10 minutes  After this time fetch new data</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="st">:valid</span> =&gt; <span class="dv">86400</span>,  <span class="co"># 1 day       Maximum time to use old data</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">                    <span class="co">#             :forever is a valid option</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="st">:period</span> =&gt; <span class="dv">60</span>,    <span class="co"># 1 minute    Maximum frequency to call API</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="st">:timeout</span> =&gt; <span class="dv">5</span>     <span class="co"># 5 seconds   API response timeout</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="st">:fail</span> =&gt;          <span class="co"># Value returned instead of exception on failure</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">}</a></code></pre></div>
<p>Before using the APICache you should set the cache to use. By default an in memory hash is used - obviously not a great idea. Thankfully APICache can use any moneta store (you may need the Moneta gem if not already installed: https://github.com/minad/moneta), so for example if you wanted to use memcache you’d do this: ```ruby</p>
</body>
</html>
