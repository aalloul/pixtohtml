<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>wyhaines_swiftiply1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="swiftiply-v1.0.0-httpgithub.comwyhainesswiftiply">Swiftiply v1.0.0 (http://github.com/wyhaines/swiftiply)</h1>
<p>Swiftiply is a backend agnostic clustering proxy for web applications that is specifically designed to support HTTP traffic from web frameworks. It is a targeted proxy, intended specifically for use in front of web frameworks, and is not a general purpose proxy.</p>
<p>What it is, though, is a very fast, narrowly targeted clustering proxy, with the current implementation being written in Ruby.</p>
<p>Swiftiply works differently from a traditional proxy. In Swiftiply, the backend processes are clients of the Swiftiply server – they make persistent socket connections to Swiftiply. One of the major advantages to this architecture is that it allows one to start or stop backend processes at will, with no configuration of the proxy. The proxy always knows exactly what resources it has available to handle a given request. The obvious disadvantage is that this is not behavior that web applications typically expect.</p>
<p>Swiftiply was originally written in an era when Mongrel was the preferred deployment method for most Ruby frameworks. Swiftiply includes a version of Mongrel(found in swiftcore/swiftiplied_mongrel.rb) that has been modified to work as a swiftiply client. This should be transparent to any existing Mongrel handlers, allowing them all to with Swiftiply.</p>
<p>Swiftiply also provides a traditional proxy model, allowing it to be used as a proxy in front of any web application.</p>
<p>TODO: Provide an implementation of a swiftiply access proxy. This is a Swiftiply TODO: “client” that maintains N connections into Swiftiply, but that operates as TODO: a traditional proxy on the web application facing side. This lets an individual TODO: server modulate the total number of connections that it is willing to handle TODO: simultaneously, while not requiring the applications themselves to know anything TODO: about it.</p>
<p>CONFIGURATION</p>
<p>Swiftiply takes a single configuration file which defines for it where it should listen for incoming connections, whether it should daemonize itself, and then provides a map of incoming domain names and the address/port to proxy that traffic to. That outgoing address/port is where the backends for that site will connect to.</p>
<p>Here’s an example:</p>
<p>cluster_address: swiftcore.org cluster_port: 80 daemonize: true map: - incoming: - swiftcore.org</p>
</body>
</html>
