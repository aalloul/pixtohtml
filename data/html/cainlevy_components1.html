<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>cainlevy_components1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="components">Components</h2>
<p>This plugin attempts to implement components in the simplest, cleanest, fastest way possible. Inspired by the Cells plugin (http://cells.rubyforge.org) by Nick Sutterer and Peter Bex.</p>
<p>A component can be thought of as a very lightweight controller with supporting view templates. The difference between a component “controller” and a Rails controller is that the component controller’s methods are very much normal methods - they accept arguments, and they return a string. There is no magical auto-rendering, and there is no access to data that is not a) in the arguments or b) in the database. For example, there is no access to the request, the request parameters, or the session. This is designed to encourage good design and reuse of components, and to ensure that they don’t take over the request/response job of your Rails controllers.</p>
<p>Speaking imprecisely, components prepare for and then render templates.</p>
<h2 id="usage">Usage</h2>
<p>Note that these examples are very simplistic and would be better implemented using Rails partials.</p>
<h3 id="generator">Generator</h3>
<p>Running <code>script/generator users details</code> will create a UsersComponent with a “details” view. You might then flesh out the templates like this:</p>
<pre><code>class UsersComponent &lt; Components::Base
  def details(user_or_id)
    @user = user_or_id.is_a?(User) ? user_or_id : User.find(user_or_id)
    render
  end
end</code></pre>
<h3 id="from-actioncontroller">From ActionController</h3>
<pre><code>class UsersController &lt; ApplicationController
  def show
    return :text =&gt; component(&quot;users/detail&quot;, params[:id])
  end
end</code></pre>
<h3 id="from-actionview">From ActionView</h3>
<pre><code>&lt;%= component &quot;users/detail&quot;, @user %&gt;</code></pre>
<h2 id="more-features">More Features</h2>
<h3 id="caching">Caching</h3>
<p>Any component action may be cached using the fragment caching you’ve configured on ActionController::Base. The command to cache a component action must come after the definition of the action itself. This is because the caching method wraps the action, which makes the caching work even if you call the action directly.</p>
<p>Example:</p>
<pre><code>class UsersComponent &lt; Components::Base
  def details(user_id)
    @user = User.find(user_id)
    render
  end
  cache :details, :expires_in =&gt; 15.minutes
end</code></pre>
</body>
</html>
