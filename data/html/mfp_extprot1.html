<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>mfp_extprot1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Note: the latest documentation can be found in <a href="http://github.com/mfp/extprot/tree/master">extprot’s git repository</a>. <strong>Click on <code>README.md</code> in the directory view so that relative links work.</strong></p>
<h2 id="introduction">Introduction</h2>
<p>extprot allows you to create compact, efficient, extensible, binary protocols that can be used for cross-language communication and long-term data serialization. extprot supports protocols with rich, composable types, whose definition can evolve while keeping both forward and backward compatibility.</p>
<p>The extprot compiler (extprotc) takes a protocol description and generates code in any of the supported languages to serialize and deserialize the associated data structures. It is accompanied by a runtime library for each target language which is used to read and write the structures defined by the protocol.</p>
<p>The protocols created using extprot are:</p>
<ul>
<li>extensible: types can be <a href="doc/extensions.md">extended in several ways</a> without breaking compatibility with existent producers/consumers</li>
<li>self-delimited: each message indicates its own length. This allows you to send sequences of messages (streaming) without having to add message delimiters.</li>
<li>self-describing: a message can be decoded even without the protocol definition. What you get is roughly equivalent to XML without the DTD.</li>
<li><a href="doc/benchmark.md">compact</a>: 2 to &gt;6 times less space than XML, typically 2 to 4 times less space than individual, compressed XML messages.</li>
<li>fast: can be deserialized <a href="doc/benchmark.md">one to two orders of magnitude faster than XML</a>, and faster than it’d take to merely uncompress XML data.</li>
</ul>
<p>There are three parts to extprot, from lower to higher level:</p>
<ol type="1">
<li>the <a href="doc/encoding.md">low-level encoding</a></li>
<li>the <a href="doc/protocol-definition.md">abstract syntax to define the protocol</a></li>
<li>the <a href="doc/language-mapping.md">mapping to the target language</a></li>
</ol>
<p>The <a href="doc/protocol-definition.md">abstract syntax</a> is what the extprot user feeds to the extprotc compiler; it defines the protocol, and controls how it maps to both the low-level encoding and the <a href="doc/language-mapping.md">target language’s data model</a>.</p>
<p>The <a href="doc/encoding.md">low-level encoding</a> is of interest to people who want to add support for additional target languages — knowledge of the low-level encoding is obviously needed for the required runtime.</p>
<h2 id="example">Example</h2>
</body>
</html>
