<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>jruby_jruby-rack6</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><em>.html</em> extension to the resource and attempt to handle it before serving a dynamic request on the original URI. However, this behavior may confuse other servlets in your application that have a wildcard mapping. Defaults to true. - <code>jruby.rack.filter.verify.resource.exists</code>: <strong>deprecated</strong> use <code>verifiesHtmlResource</code> filter config init parameter. If <code>jruby.rack.filter.adds.html</code> is true, then this setting, when true, adds an additional check using <code>ServletContext#getResource</code> to verify that the <em>.html</em> resource exists. Default is false. (Note that apparently some servers may not implement <code>getResource</code> in the way that is expected here, so in that case this setting won’t matter.)</p>
<h2 id="initialization">Initialization</h2>
<p>There are often cases where you need to perform custom initialization of the Ruby environment before booting the application. You can create a file called <em>META-INF/init.rb</em> or <em>WEB-INF/init.rb</em> inside the war file for this purpose. These files, if found, will be evaluated before booting the Rack environment, allowing you to set environment variables, load scripts, etc.</p>
<p>For plain Rack applications, JRuby-Rack also supports a magic comment to solve the “rackup” chicken-egg problem (you need Rack’s builder loaded before loading the <em>config.ru</em>, yet you may want to setup the gem version from within the rackup file). As we ship with the Rack gem bundled, otherwise when executing the provided <em>config.ru</em> the bundled (latest) version of Rack will get loaded.</p>
<p>Use <strong>rack.version</strong> to specify the Rack gem version to be loaded before rackup :</p>
<pre><code># encoding: UTF-8
# rack.version: ~&gt;1.3.6 (before code is loaded gem &#39;~&gt;1.3.6&#39; will be called)</code></pre>
<p>Or the equivalent of doing <code>bundle exec rackup ...</code> if you’re using Bundler :</p>
<pre><code># rack.version: bundler (requires &#39;bundler/setup&#39; before loading the script)</code></pre>
<h2 id="logging">Logging</h2>
<p>JRuby-Rack sets up a delegate logger for Rails that sends logging output to <code>javax.servlet.ServletContext#log</code> by default. If you wish to use a different logging system, configure <code>jruby.rack.logging</code> as follows:</p>
<ul>
<li><code>servlet_context</code> (default): Sends log messages to the servlet context.</li>
<li><code>stdout</code>: Sends log messages to the standard output stream <code>System.out</code>.</li>
<li><code>slf4j</code>: Sends log messages to SLF4J. SLF4J configuration is left up to you, please refer to http://www.slf4j.org/docs.html .</li>
<li><code>log4j</code>: Sends log messages to log4J. Again, Log4J configuration is left up to you, consult http://logging.apache.org/log4j/ .</li>
<li><code>commons_logging</code>: Routes logs to commons-logging. You still need to configure an underlying logging implementation with JCL. We recommend using the logger</li>
</ul>
</body>
</html>
