<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>robey_smile1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="smile">SMILE</h1>
<p>Smile is a memcache library for scala which is intended to be fast and highly concurrent. It is open-sourced under the Apache 2 license.</p>
<p>All the standard key hashing functions are supported (CRC-ITU, FNV, and Ketama). Support for round-robin (“default”) and Ketama key distributions is built-in. User-defined key hashing and distribution functions can be trivially added via the API.</p>
<p>Server lists and configuration may be set manually or via blocks. User-defined key hashing and distribution may be specified in the config block – just be sure to add them via the API first! :)</p>
<p>Author: Robey Pointer <a href="mailto:robeypointer@gmail.com">robeypointer@gmail.com</a></p>
<h2 id="strategy">Strategy</h2>
<p>is used as a library for handling asynchronous I/O via java NIO, and the memcache protocol is implemented using the naggati DSL for building Mina protocol state machines. I/O events are forwarded to scala actors, with one actor for each memcache server connection. It acts like a thread-pool but ensures that each server’s traffic is handled sequentially, with very simple code.</p>
<p>!</p>
<h2 id="performance">Performance</h2>
<p>A performance test is included as an ant target. It requires you to have 3 memcached servers running on localhost, on ports 11211, 11212, and 11213:</p>
<pre><code>$ ant manygets
manygets:
     [java] serial gets: 1000
     [java] toasters: 1000 in 797 msec (0.80 msec each)
     [java] parallel gets: 1000 on 10 threads
     [java] toasters: 10000 in 2992 msec (0.30 msec each)
     [java] parallel gets: 1000 on 10 threads from 3 servers
     [java] toasters: 10000 in 2048 msec (0.20 msec each)
     </code></pre>
<p>The first test does 1000 memcache “get” operations in a row, from a single</p>
</body>
</html>
