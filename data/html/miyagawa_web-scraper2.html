<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>miyagawa_web-scraper2</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>XPath expressions.</p>
<h1 id="methods">METHODS</h1>
<h2 id="scraper">scraper</h2>
<pre><code>$scraper = scraper { ... };</code></pre>
<p>Creates a new Web::Scraper object by wrapping the DSL code that will be fired when <em>scrape</em> method is called.</p>
<h2 id="scrape">scrape</h2>
<pre><code>$res = $scraper-&gt;scrape(URI-&gt;new($uri));
$res = $scraper-&gt;scrape($html_content);
$res = $scraper-&gt;scrape(\$html_content);
$res = $scraper-&gt;scrape($http_response);
$res = $scraper-&gt;scrape($html_element);</code></pre>
<p>Retrieves the HTML from URI, HTTP::Response, HTML::Tree or text strings and creates a DOM object, then fires the callback scraper code to retrieve the data structure.</p>
<p>If you pass URI or HTTP::Response object, Web::Scraper will automatically guesses the encoding of the content by looking at Content-Type headers and META tags. Otherwise you need to decode the HTML to Unicode before passing it to <em>scrape</em> method.</p>
<p>You can optionally pass the base URL when you pass the HTML content as a string instead of URI or HTTP::Response.</p>
<pre><code>$res = $scraper-&gt;scrape($html_content, &quot;http://example.com/foo&quot;);</code></pre>
<p>This way Web::Scraper can resolve the relative links found in the document.</p>
<h2 id="process">process</h2>
<pre><code>scraper {
    process &quot;tag.class&quot;, key =&gt; &#39;TEXT&#39;;
    process &#39;//tag[contains(@foo, &quot;bar&quot;)]&#39;, key2 =&gt; &#39;@attr&#39;;
    process &#39;//comment()&#39;, &#39;comments[]&#39; =&gt; &#39;TEXT&#39;;
};</code></pre>
<p><em>process</em> is the method to find matching elements from HTML with CSS selector or XPath expression, then extract text or attributes into the result stash.</p>
<p>If the first argument begins with “//” or “id(” it’s treated as an XPath expression and otherwise CSS selector.</p>
<pre><code># &lt;span class=&quot;date&quot;&gt;2008/12/21&lt;/span&gt;</code></pre>
</body>
</html>
