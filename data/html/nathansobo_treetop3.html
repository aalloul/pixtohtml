<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>nathansobo_treetop3</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<pre><code># parentheses.treetop
grammar Parentheses
  rule parens
    &#39;(&#39; parens &#39;)&#39; / &#39;&#39;
  end
end</code></pre>
<p>The <code>parens</code> expression simply states that a <code>parens</code> is a set of parentheses surrounding another <code>parens</code> expression or, if that doesn’t match, the empty string. If you are uncomfortable with recursion, its time to get comfortable, because it is the basis of language. Here’s a tip: Don’t try and imagine the parser circling round and round through the same rule. Instead, imagine the rule is <em>already</em> defined while you are defining it. If you imagine that <code>parens</code> already matches a string of matching parentheses, then its easy to think of <code>parens</code> as an open and closing parentheses around another set of matching parentheses, which conveniently, you happen to be defining. You know that <code>parens</code> is supposed to represent a string of matched parentheses, so trust in that meaning, even if you haven’t fully implemented it yet.</p>
<h2 id="repetition">Repetition</h2>
<p>Any item in a rule may be followed by a ‘+’ or a ’*’ character, signifying one-or-more and zero-or-more occurrences of that item. Beware though; the match is greedy, and if it matches too many items and causes subsequent items in the sequence to fail, the number matched will never be reconsidered. Here’s a simple example of a rule that will never succeed:</p>
<pre><code># toogreedy.treetop
grammar TooGreedy
  rule a_s
    &#39;a&#39;* &#39;a&#39;
  end
end</code></pre>
<p>The ‘a’* will always eat up any ‘a’s that follow, and the subsequent ’a’ will find none there, so the whole rule will fail. You might need to use lookahead to avoid matching too much. Alternatively, you can use an occurrence range:</p>
<pre><code># toogreedy.treetop
grammar TooGreedy
  rule two_to_four_as
    &#39;a&#39; 2..4
  end
end</code></pre>
<p>In an occurrence range, you may omit either the minimum count or the maximum count, so that “0..” works like “*&quot; and “1..” works like ‘+’.</p>
<h2 id="negative-lookahead">Negative Lookahead</h2>
<p>When you need to ensure that the following item <em>doesn’t</em> match in some case where it might otherwise, you can use negat!ve lookahead, which is an item preceeded by a ! - here’s an example:</p>
<pre><code># postcondition.treetop
grammar PostCondition
  rule conditional_sentence
    ( !conditional_keyword word )+ conditional_keyword [ \t]+ word*
  end

  rule word
    ([a-zA-Z]+ [ \t]+) 
  end

  rule conditional_keyword
    &#39;if&#39; / &#39;while&#39; / &#39;until&#39;</code></pre>
</body>
</html>
