<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>okomok_mada3</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<ul>
<li><em>Sequence</em> is represented by <code>&gt;&gt;</code>, because Scala doesn’t have “blank” operator.</li>
<li><em>And-predicate</em> is represented by <code>~</code>, because Scala doesn’t have unary <code>&amp;</code> operator.</li>
<li><code>peg.from</code> may be needed to bust ambiguity.</li>
<li>No scanners.</li>
<li><code>peg.Rule</code> is used to represent recursive grammars. (<code>lazy val</code> isn’t used.)</li>
<li><em>Semantic Action</em> is passed using <code>{...}</code>. (<code>(...)</code> too can be used.)</li>
</ul>
<h2 id="sequence">sequence</h2>
<p><code>sequence</code> provides four sequence types:</p>
<ol type="1">
<li><code>Reactive</code>, reactive sequence</li>
<li><code>Iterative</code>, iterable sequence</li>
<li><code>List</code>, recursive sequence</li>
<li><code>Vector</code>, random-access sequence</li>
</ol>
<p>These construct a loosely arranged hierarchy (like Scala-2.7 collections): <code>List</code> and <code>Vector</code> is compatible to <code>Iterative</code>, which is compatible to <code>Reactive</code>.</p>
<h3 id="reactive">Reactive</h3>
<p><code>Reactive</code> sequence is a logical base trait for all kinds of <code>mada</code> sequences. This is built upon (possibly) asynchronous <code>foreach</code>:</p>
<pre><code>reactive.block { * =&gt;
    val mouse = reactive.Swing.Mouse(jl)
    for (p &lt;- *(mouse.Pressed)) {
        println(&quot;pressed at: &quot; + (p.getX, p.getY))
        for (d &lt;- *(mouse.Dragged.stepTime(100).takeUntil(mouse.Released))) {
            println(&quot;dragging at: &quot; + (d.getX, d.getY))
        }
        println(&quot;released&quot;)
    }
}</code></pre>
<p><code>Reactive</code> summary:</p>
<ul>
<li><code>foreach</code> may be asynchronous; a function passed to <code>foreach</code> may be called later.</li>
<li><code>block</code> can be used to build a sugared for-comprehension with the help of continuations plugin.</li>
<li>Synchronous algorithms(<code>isEmpty</code>, <code>head</code> etc) are not supplied.</li>
</ul>
<p>References:</p>
<ul>
<li>[scala.react]</li>
<li>[scala.Responder]</li>
<li>[scala.collection.Traversable]</li>
</ul>
</body>
</html>
