<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>sebastien_extend4</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Returns the class object associated with this instance. You can use the class object to access class operations, class attributes, etc.</p>
<p>‘<Instance>.getMethod(name:String):Function’:: In JavaScript, if you give a method as a callback by simply doing ‘object.method’, then you may have problems when the caller changes the ‘this’ argument of the method. Using ‘getMethod’ will ensure that the this is preserved. It’s actually an equivalent of doing ‘this.getClass().bindMethod(this, name)’, except that successive calls to ‘getMethod(…)’ will always return the same function object, while ‘bindMethod’ will create a new function each time (useful to know when you’re using jQuery ‘bind’/‘unbind’ functions).</p>
<p>‘<Instance>.getCallback(name:String):Function’:: The ‘getCallback’ method is similar to ‘getMethod’, except that it will add an extra argument which is the ‘this’ used when invoking the method. Libraries such as <a href="http://www.jquery.com">jQuery</a> change the ‘this’ of callbacks given to events such as ‘click’ or ‘focus’ to the DOM node that received the event rather than the instance to which the method is bound. Using ‘getMethod’ insulates you from this change, but you also lose the reference to the DOM node that received the event (the event target). When using ‘getCallback’, you’ll have the target as an additional argument.</p>
<p>‘<Instance>.getSuper(c:Class):Object’:: Returns a proxy that will use the current object as state, but where every operation defined in the proxy will use the implementation defined in the given class.</p>
<p>‘<Instance>.isInstance(c:Class):Boolean’:: Returns ‘true’ if this instance is an instance of the given class, which must be either the class of this instance, or an ancestor of this instance class.</p>
<h2 id="class-api">Class API</h2>
<p>The <em>class API</em> defines the methods which are available for class objects resulting from the use of the Extend API.</p>
<p>‘<Class>.isClass():Boolean’:: Tells if the given object is class or not. This returns ‘true’</p>
<p>‘<Class>.getName():String’:: Returns the class name, as given when creating the class.</p>
<p>‘<Class>.getParent():extend.Class’:: Returns the parent class for this class, or ‘undefined’.</p>
<p>‘<Class>.hasInstance(o:Object):Boolean’:: Tells if the given object is an instance of this class. This also includes</p>
</body>
</html>
