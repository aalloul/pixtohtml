<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>jmibanez_jmeter-rmi-plugin2</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>application provides, and will use those transparently as per the RMI specification.</p>
<h2 id="recording-rmi-calls">Recording RMI Calls</h2>
<p>To record your application’s RMI calls, you must point your application to the registry exposed by the RMI Proxy provided by this plugin.</p>
<ol type="1">
<li>Add the <code>RMI Proxy</code> to your workbench.</li>
<li>Change <code>Target RMI Name</code> to point to your application’s RMI server. The proxy can currently only bind to a single named remote, but will also monitor and track remotes returned by methods of that named remote.</li>
<li>Configure the proxy’s registry port by changing <code>Proxy Naming Port</code>. The default should be fine.</li>
<li>Configure the port where the proxy’s equivalent remote instance will listen in. This may be important if you need to punch holes on your firewall for RMI.</li>
<li>Optionally, if your application code needs some configuration for serialization (e.g. setting certain static variables as configuration, etc.), you can provide a BeanShell script that will be evaluated once the proxy has started and looked up the remote object at <code>Target RMI Name</code>. See Binding Script below for more info.</li>
<li>Click <code>Start</code> to start the proxy.</li>
<li>Run your application, pointing to the RMI name configured for the proxy.</li>
</ol>
<p>For example, if your application’s RMI server exposes a remote object at <code>//192.168.56.1:1099/myService</code>, you can use the following settings:</p>
<ul>
<li>Target RMI Name: <code>//192.168.56.1:1099/myService</code></li>
<li>Proxy Naming Port: <code>1100</code></li>
<li>Proxy Port: <code>1101</code></li>
<li>RMI Name for your application <code>//&lt;your local IP address&gt;:1100/myService</code></li>
</ul>
<h3 id="binding-script">Binding Script</h3>
<p>To configure any necessary static variables your application may need to be set beforehand, for instance due to logic in your Serializable classes, you can provide a <em>binding script</em>. The binding script on the RMI Proxy is a BeanShell scriptlet that is evaluated at binding time (i.e. when the proxy has started, and looked up your remote instance, and replaced it with a recording proxy). The following variables are available within the context of the binding script:</p>
<ul>
<li><code>proxy</code>: The proxy of the remote instance, provided by the plugin. Any method call made by your scriptlet on this object will</li>
</ul>
</body>
</html>
