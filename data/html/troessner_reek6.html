<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>troessner_reek6</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h3 id="configuration-file">Configuration file</h3>
<h4 id="configuration-loading">Configuration loading</h4>
<p>Configuring Reek via a configuration file is by far the most powerful way.</p>
<p>There are three ways of passing Reek a configuration file:</p>
<ol type="1">
<li>Using the CLI <code>-c</code> switch (see <a href="#command-line-interface"><em>Command-line interface</em></a> above)</li>
<li>Having a file ending with <code>.reek</code> either in your current working directory or in a parent directory (more on that later)</li>
<li>Having a file ending with <code>.reek</code> in your home directory</li>
</ol>
<p>The order in which Reek tries to find such a configuration file is exactly the above: first it checks if we have given it a configuration file explicitly via CLI; then it checks the current working directory for a file and if it can’t find one, it traverses up the directories until it hits the root directory; lastly, it checks your home directory.</p>
<p>As soon as Reek detects a configuration file it stops searching immediately, meaning that from Reek’s point of view there exists exactly one configuration file and one configuration, regardless of how many <code>*.reek</code> files you might have on your filesystem.</p>
<h4 id="configuration-options">Configuration options</h4>
<p>We put a lot of effort into making Reek’s configuration as self explanatory as possible so the best way to understand it is by looking at a simple example (e.g. <code>config.reek</code> in your project directory):</p>
<h2 id="yaml">```yaml</h2>
<h3 id="generic-smell-configuration">Generic smell configuration</h3>
<h1 id="you-can-disable-smells-completely">You can disable smells completely</h1>
<p>IrresponsibleModule: enabled: false</p>
<h1 id="you-can-use-filters-to-silence-reek-warnings.">You can use filters to silence Reek warnings.</h1>
<h1 id="either-because-you-simply-disagree-with-reek-we-are-not-the-police-or">Either because you simply disagree with Reek (we are not the police) or</h1>
<h1 id="because-you-want-to-fix-this-at-a-later-point-in-time.">because you want to fix this at a later point in time.</h1>
<p>NestedIterators: exclude: - “MyWorker#self.class_method” # should be refactored - “AnotherWorker#instance_method” # should be refactored as well</p>
<h1 id="a-lot-of-smells-allow-fine-tuning-their-configuration.-you-can-look-up-all-available-options">A lot of smells allow fine tuning their configuration. You can look up all available options</h1>
<h1 id="in-the-corresponding-smell-documentation-in-docs.-in-most-cases-you-probably-can-just-go">in the corresponding smell documentation in /docs. In most cases you probably can just go</h1>
</body>
</html>
