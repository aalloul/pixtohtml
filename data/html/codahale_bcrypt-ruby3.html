<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>codahale_bcrypt-ruby3</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h3 id="background">Background</h3>
<p>Hash algorithms take a chunk of data (e.g., your user’s password) and create a “digital fingerprint,” or hash, of it. Because this process is not reversible, there’s no way to go from the hash back to the password.</p>
<p>In other words:</p>
<pre><code>hash(p) #=&gt; &lt;unique gibberish&gt;</code></pre>
<p>You can store the hash and check it against a hash made of a potentially valid password:</p>
<pre><code>&lt;unique gibberish&gt; =? hash(just_entered_password)</code></pre>
<h3 id="rainbow-tables">Rainbow Tables</h3>
<p>But even this has weaknesses – attackers can just run lists of possible passwords through the same algorithm, store the results in a big database, and then look up the passwords by their hash:</p>
<pre><code>PrecomputedPassword.find_by_hash(&lt;unique gibberish&gt;).password #=&gt; &quot;secret1&quot;</code></pre>
<h3 id="salts">Salts</h3>
<p>The solution to this is to add a small chunk of random data – called a salt – to the password before it’s hashed:</p>
<pre><code>hash(salt + p) #=&gt; &lt;really unique gibberish&gt;</code></pre>
<p>The salt is then stored along with the hash in the database, and used to check potentially valid passwords:</p>
<pre><code>&lt;really unique gibberish&gt; =? hash(salt + just_entered_password)</code></pre>
<p>bcrypt-ruby automatically handles the storage and generation of these salts for you.</p>
<p>Adding a salt means that an attacker has to have a gigantic database for each unique salt – for a salt made of 4 letters, that’s 456,976 different databases. Pretty much no one has that much storage space, so attackers try a different, slower method – throw a list of potential passwords at each individual password:</p>
<pre><code>hash(salt + &quot;aadvark&quot;) =? &lt;really unique gibberish&gt;
hash(salt + &quot;abacus&quot;)  =? &lt;really unique gibberish&gt;
etc.</code></pre>
<p>This is much slower than the big database approach, but most hash algorithms are pretty quick – and therein lies the problem. Hash algorithms aren’t usually designed to be slow, they’re designed to turn gigabytes of data into secure fingerprints as quickly as possible. <code>bcrypt()</code>, though, is designed to be computationally expensive:</p>
<pre><code>Ten thousand iterations:
             user     system      total        real
md5      0.070000   0.000000   0.070000 (  0.070415)
bcrypt  22.230000   0.080000  22.310000 ( 22.493822)</code></pre>
<p>If an attacker was using Ruby to check each password, they could check ~140,000 passwords a second with MD5 but only</p>
</body>
</html>
